(function(aoc) {
    const start = ".#./..#/###";

    aoc.days["21"] = {
        actualInput: `
            ../.. => ##./###/...
            #./.. => ..#/##./##.
            ##/.. => #.#/##./...
            .#/#. => ##./###/###
            ##/#. => ###/.#./#.#
            ##/## => .#./.#./###
            .../.../... => #.../.#.#/..##/#...
            #../.../... => .##./#.##/##../##..
            .#./.../... => ##../#.../.#.#/###.
            ##./.../... => .#.#/###./.#.#/.#..
            #.#/.../... => .#.#/##../.#../###.
            ###/.../... => #.##/.##./..##/#.##
            .#./#../... => #..#/...#/.###/.##.
            ##./#../... => .###/..#./#.../####
            ..#/#../... => ..../.#../#.##/....
            #.#/#../... => ..##/.##./.##./....
            .##/#../... => ###./#.../#.#./.#.#
            ###/#../... => .#../##.#/.#.#/..#.
            .../.#./... => ####/##../..#./#..#
            #../.#./... => ####/#.##/#..#/..#.
            .#./.#./... => #.##/.#../.#../.#.#
            ##./.#./... => ..##/###./..../...#
            #.#/.#./... => ...#/.#.#/.#../....
            ###/.#./... => ..../..#./#..#/##.#
            .#./##./... => ##../.#.#/#.#./.#.#
            ##./##./... => ###./##.#/#.#./.##.
            ..#/##./... => ..#./.#.#/###./##.#
            #.#/##./... => ##.#/.#../#.../#.#.
            .##/##./... => ####/..../...#/#.##
            ###/##./... => ####/.###/.###/.###
            .../#.#/... => .#.#/###./.##./.#..
            #../#.#/... => #.##/#..#/#..#/##..
            .#./#.#/... => ...#/##../..../#..#
            ##./#.#/... => #..#/.#../##.#/..##
            #.#/#.#/... => ..../...#/..#./#..#
            ###/#.#/... => .##./#..#/...#/.##.
            .../###/... => ..../#.##/.#../##..
            #../###/... => .#.#/.###/###./#..#
            .#./###/... => ...#/.#../###./.###
            ##./###/... => #..#/###./#.##/.#..
            #.#/###/... => .#../##../###./.#.#
            ###/###/... => ###./.#.#/.##./###.
            ..#/.../#.. => ...#/#..#/###./.###
            #.#/.../#.. => #.#./#.##/#.#./...#
            .##/.../#.. => .#.#/#.#./..../#.##
            ###/.../#.. => ##.#/..##/.#.#/##..
            .##/#../#.. => ####/#..#/.#.#/...#
            ###/#../#.. => .#.#/####/..##/.#.#
            ..#/.#./#.. => ##.#/.#../#.../.##.
            #.#/.#./#.. => #..#/.#.#/#.#./#..#
            .##/.#./#.. => #..#/..#./#.../...#
            ###/.#./#.. => #.##/.#../#.##/##.#
            .##/##./#.. => .###/..../#..#/.##.
            ###/##./#.. => #.../.#.#/..#./.#..
            #../..#/#.. => ..../##../#.../##.#
            .#./..#/#.. => ..##/...#/###./##..
            ##./..#/#.. => .#.#/.###/...#/.#.#
            #.#/..#/#.. => .#../..../.###/.##.
            .##/..#/#.. => #.##/.##./.##./####
            ###/..#/#.. => #.../.#../..../#...
            #../#.#/#.. => .#../.#.#/..##/###.
            .#./#.#/#.. => ##.#/#.##/...#/#.##
            ##./#.#/#.. => .##./####/.#.#/.#..
            ..#/#.#/#.. => #.##/##.#/..#./.###
            #.#/#.#/#.. => ###./.#../###./###.
            .##/#.#/#.. => .#../.#../####/##.#
            ###/#.#/#.. => #.##/##.#/#.../##..
            #../.##/#.. => ..#./.###/#.#./..#.
            .#./.##/#.. => ##.#/##../..#./#...
            ##./.##/#.. => #.../..#./#.../.#..
            #.#/.##/#.. => ..#./#.##/.##./####
            .##/.##/#.. => #.#./.#../####/..##
            ###/.##/#.. => ...#/#..#/#.../.#..
            #../###/#.. => ..../..../##.#/.##.
            .#./###/#.. => ..##/..#./##../....
            ##./###/#.. => .#../..##/..../.#.#
            ..#/###/#.. => ...#/...#/..#./###.
            #.#/###/#.. => ####/##.#/##../..##
            .##/###/#.. => ..##/##../#..#/##..
            ###/###/#.. => ##.#/.##./...#/.#.#
            .#./#.#/.#. => ###./####/.##./#..#
            ##./#.#/.#. => #.../..#./.##./##..
            #.#/#.#/.#. => .##./####/##../.#.#
            ###/#.#/.#. => ##../..../.#.#/....
            .#./###/.#. => ..##/##.#/.##./.#.#
            ##./###/.#. => #.../.#../..##/..#.
            #.#/###/.#. => ####/.##./#..#/...#
            ###/###/.#. => ####/..../##.#/.#.#
            #.#/..#/##. => ####/####/####/#...
            ###/..#/##. => #.#./####/##.#/####
            .##/#.#/##. => .###/#.../#.../...#
            ###/#.#/##. => ..#./#.#./##../##.#
            #.#/.##/##. => ###./###./#..#/.###
            ###/.##/##. => ##.#/..#./##../....
            .##/###/##. => ##.#/###./.#.#/.##.
            ###/###/##. => #.##/.#.#/#..#/.##.
            #.#/.../#.# => ..#./####/...#/#.##
            ###/.../#.# => .##./..#./####/#...
            ###/#../#.# => .##./##../..../###.
            #.#/.#./#.# => #.##/#.##/#.##/#...
            ###/.#./#.# => ####/#.##/####/.###
            ###/##./#.# => .#.#/..../.#.#/#.##
            #.#/#.#/#.# => ###./#.##/####/.###
            ###/#.#/#.# => .##./.##./.#.#/....
            #.#/###/#.# => ##../..##/...#/.##.
            ###/###/#.# => .#../#.##/..##/.#..
            ###/#.#/### => ##.#/..#./...#/.###
            ###/###/### => ..##/###./.###/.###
        `,

        puzzles:[{
            title: "Puzzle 1",
            expectedAnswer: null,
            testSets: [
                { expectedAnswer: 12, data: `
                    ../.# => ##./#../...
                    .#./..#/### => #..#/..../..../#..#
                ` },
                { expectedAnswer: 12, data: `
                    ../.# => ##./#../...
                    ###/..#/.#. => #..#/..../..../#..#
                ` },
                { expectedAnswer: 12, data: `
                    ../.# => ##./#../...
                    #../#.#/##. => #..#/..../..../#..#
                ` },
            ],
            getSolution: data => {
                function logPattern(pattern) {
                    pattern.split("/").forEach((l,i) => console.log(`${i}  =>   ${l}`));
                }

                let pattern = start.slice();

                let instructions = data
                    .split(/\r?\n/g)
                    .map(l => l.trim())
                    .filter(l => !!l)
                    .map(l => {
                        let parts = l.split(" => ").map(p => p.trim());
                        return {
                            pattern: parts[0],
                            output: parts[1],
                        };
                    })
                    .reduce((map, i) => {
                        map[i.pattern] = i;
                        return map;
                    }, {});

                // YUCK
                let isTestPuzzle = Object.keys(instructions).length < 3;
                let iterations = isTestPuzzle ? 2 : 5;

                let idx = 0;
                while (idx++ < iterations) {
                    let thing = chop(pattern);

                    for (let i = 0; i < thing.squares.length; i++) {
                        let op = getOperation(thing.squares[i]);
                        if (!!op) {
                            thing.squares[i] = op.output;
                        }
                    }

                    pattern = combine(thing);
                }

                // Not 18
                // Not 5
                return pattern.match(/#/g).length;
            }
        },

        /*{
            title: "Puzzle 2",
            expectedAnswer: null,
            testSets: [
                { expectedAnswer: null, data: [] },
            ],
            getSolution: data => {
                let input = data;

                return "NOT FOUND";
            }
        }*/]

        ,bonusTests: [{
            title: "Can gridify base pattern into grid",
            test: assert => {
                //   .#.
                //   ..#
                //   ###

                let input = start.slice();
                let grid = gridify(input);
                assert.deepEqual(grid, [[".","#","."],[".",".","#"],["#","#","#"]]);
            }
        },{
            title: "Can count 'on' pixels in grid",
            test: assert => {
                //   .#.
                //   ..#
                //   ###

                let input = start.slice();
                let grid = gridify(input);
                let result = countPixels(grid);
                assert.deepEqual(result, 5);
            }
        },{
            title: "Can chop 4x4 grid into 2x2 blocks",
            test: assert => {
                //   ####
                //   #..#
                //   #..#
                //   ####

                let grid = gridify("####/#..#/#..#/####");
                let chops = chop(grid);

                assert.deepEqual(chops, [
                    [["#","#"],["#","."]], //   ##/#.
                    [["#","#"],[".","#"]], //   ##/.#
                    [["#","."],["#","#"]], //   #./##
                    [[".","#"],["#","#"]]  //   .#/##
                ]);
            }
        },{
            title: "Can chop 6x6 grid into 2x2 blocks",
            test: assert => {
                //   ######
                //   #....#
                //   #....#
                //   #....#
                //   #....#
                //   ######

                let grid = gridify("######/#....#/#....#/#....#/#....#/######");
                let chops = chop(grid);

                assert.deepEqual(chops, [
                    [["#","#"],["#","."]], //   ##/#.
                    [["#","#"],[".","."]], //   ##/..
                    [["#","#"],[".","#"]], //   ##/.#

                    [["#","."],["#","."]], //   #./#.
                    [[".","."],[".","."]], //   .../..
                    [[".","#"],[".","#"]], //   .#/.#

                    [["#","."],["#","#"]], //   #./##
                    [[".","."],["#","#"]], //   ../##
                    [[".","#"],["#","#"]], //   .#/##
                ]);
            }
        },{
            title: "Can chop 9x9 grid into 3x3 blocks",
            test: assert => {
                //   ###  ###  ###
                //   #..  ...  ..#
                //   #..  ...  ..#
                //
                //   #..  ...  ..#
                //   #..  ...  ..#
                //   #..  ...  ..#
                //
                //   #..  ...  ..#
                //   #..  ...  ..#
                //   ###  ###  ###

                let grid = gridify("#########/#.......#/#.......#/#.......#/#.......#/#.......#/#.......#/#.......#/#########");
                let chops = chop(grid);

                let chopPatterns = chops.map(ch => {
                    return
                })

                assert.deepEqual(chops, [
                    [["#","#","#"],["#",".","."],["#",".","."]],
                    [["#","#","#"],[".",".","."],[".",".","."]],
                    [["#","#","#"],[".",".","#"],[".",".","#"]],

                    [["#",".","."],["#",".","."],["#",".","."]],
                    [[".",".","."],[".",".","."],[".",".","."]], // MIDDLE BLOCK
                    [[".",".","#"],[".",".","#"],[".",".","#"]],

                    [["#",".","."],["#",".","."],["#","#","#"]],
                    [[".",".","."],[".",".","."],["#","#","#"]],
                    [[".",".","#"],[".",".","#"],["#","#","#"]],
                ]);
            }
        },{
            title: "Can convert 2x2 chop to pattern",
            test: assert => {
                let chop1 = [["#","#"],[".","."]];
                let pattern = patternize(chop1);
                assert.strictEqual(pattern, "##/..");
            }
        },{
            title: "Can convert 3x3 chop to pattern",
            test: assert => {
                let chop1 = [["#","#","#"],[".",".","."],[".",".","."]];
                let pattern = patternize(chop1);
                assert.strictEqual(pattern, "###/.../...");
            }
        }]
    };

    function patternize(chop) {
        return chop.map(row => row.join("")).join("/");
    }

    function chop(grid) {
        let gridSize = grid.length; // Size of a line *is* size of a *square* grid
        let divisor = (gridSize % 2 === 0) ? 2 : 3;
        let blocksPerRow = gridSize / divisor;
        let blockRow = 0;
        let rowInBlock = 0;

        let blocks = [];

        for (let y = 0; y < gridSize; y++) {
            blockRow = Math.floor(y / divisor);

            for (let x = 0, n = 0; x < gridSize; x += divisor, n++) {
                let idx = (blockRow * blocksPerRow) + n;
                let chunk = grid[y].slice(x, x + divisor);

                blocks[idx] = blocks[idx] || [];
                blocks[idx].push(chunk);
            }
        }

        return blocks;
    }

    function gridify(pattern) {
        return pattern.split("/").map(l => l.trim().split(""));;
    }

    function countPixels(grid) {
        return grid
            .map(l => l.reduce((a, b) => a + (b === "#" ? 1 : 0), 0))
            .reduce((a,b) => a + b, 0);
    }

}(window.aoc = window.aoc || {days:{}}));